# CellChat Analysis for Multiple Time Points
# File: cellchat_analysis.R
# Author: Generated by ChatGPT
# Description: Split Seurat object by timepoints, run CellChat per subset, merge and visualize

# 1. Load required libraries
library(Seurat)
library(CellChat)
library(patchwork)

# 2. Read in Seurat object
seurat_obj <- readRDS("onc_mfd.rds")

# 3. Define timepoint metadata column (adjust if different)
orig.ident <- "timepoint"  # column in seurat_obj@meta.data containing 6 time points

# 4. Split Seurat object into a list by timepoint
seurat_list <- SplitObject(seurat_obj, split.by = orig.ident)

# 5. Initialize list to store CellChat objects
cellchat_list <- list()

# 6. Loop through each timepoint subset
for (tp in names(seurat_list)) {
  cat("Processing timepoint:", tp, "\n")
  so <- seurat_list[[tp]]
  data_input <- GetAssayData(so, assay = "RNA", slot = "data")
  meta_input <- so@meta.data

  # Create CellChat object
  cc <- createCellChat(object = data_input, meta = meta_input, group.by = "ident")
  cc@DB <- CellChatDB.mouse  # or CellChatDB.human

  # Preprocessing
  cc <- subsetData(cc)
  cc <- identifyOverExpressedGenes(cc)
  cc <- identifyOverExpressedInteractions(cc)
  cc <- projectData(cc, PPI.mouse)

  # Communication probability
  cc <- computeCommunProb(cc)
  cc <- filterCommunication(cc, min.cells = 10)
  cc <- computeCommunProbPathway(cc)
  cc <- aggregateNet(cc)

  # Store
  cellchat_list[[tp]] <- cc
}

# 7. Merge all CellChat objects
time_labels <- names(cellchat_list)
combined_cc <- mergeCellChat(cellchat_list, merge.names = time_labels)

# 8. Save merged CellChat object
saveRDS(combined_cc, file = "cellchat_merged.rds")

# 9. Visualizations on merged object
# a) Aggregate hierarchy
pdf("merged_hierarchy.pdf", width = 8, height = 6)
netVisual_aggregate(combined_cc, layout = "hierarchy")
dev.off()

# b) Heatmap across timepoints
pdf("merged_heatmap.pdf", width = 8, height = 6)
netVisual_heatmap(combined_cc, signaling = NULL, color.heatmap = "Reds")
dev.off()

# c) Temporal dynamics per pathway
pathways <- unique(combined_cc@DB$interaction_name)
# Example: plot for top 5 pathways by interaction count
top_pathways <- head(sort(table(combined_cc@netP$pathway), decreasing = TRUE), 5)
pdfs <- paste0("merged_pathway_", names(top_pathways), ".pdf")
for (i in seq_along(names(top_pathways))) {
  pw <- names(top_pathways)[i]
  pdf(pdfs[i], width = 8, height = 6)
  netVisual_aggregate(combined_cc, signaling = pw, layout = "circle")
  dev.off()
}

# End of script
